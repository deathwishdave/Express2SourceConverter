/* -*-c++-*- IFC++ www.ifcquery.com  Copyright (c) 2017 Fabian Gerold */

#include <assert.h>
#include <fstream>
#include <iostream>

#include <QFile>
#include <QFileInfo>
#include <QDir>
#include <QTextStream>

#include "schema/entity/Attribute.h"
#include "schema/entity/Entity.h"
#include "schema/type/Type.h"
#include "schema/CodeFormat.h"
#include "ExpressToSourceConverter.h"

ExpressToSourceConverter::ExpressToSourceConverter()
{
	//                                     key=EXPRESS typename          EXPRESS     C++            IFC++
	m_basic_types.insert( std::make_pair( "INTEGER",	shared_ptr<IfcPPBasicType>( new IfcPPBasicType( "INTEGER",	"int",			"Int" ) ) ) );
	m_basic_types.insert( std::make_pair( "REAL",		shared_ptr<IfcPPBasicType>( new IfcPPBasicType( "REAL",		"double",		"Real" ) ) ) );
	m_basic_types.insert( std::make_pair( "NUMBER",		shared_ptr<IfcPPBasicType>( new IfcPPBasicType( "NUMBER",	"int",			"Int" ) ) ) );
	m_basic_types.insert( std::make_pair( "STRING",		shared_ptr<IfcPPBasicType>( new IfcPPBasicType( "STRING",	"std::wstring",	"String" ) ) ) );
	m_basic_types.insert( std::make_pair( "BOOLEAN",	shared_ptr<IfcPPBasicType>( new IfcPPBasicType( "BOOLEAN",	"bool",			"Bool" ) ) ) );
	m_basic_types.insert( std::make_pair( "LOGICAL",	shared_ptr<IfcPPBasicType>( new IfcPPBasicType( "LOGICAL",	"LogicalEnum",	"Logical" ) ) ) );
	m_basic_types.insert( std::make_pair( "BINARY",		shared_ptr<IfcPPBasicType>( new IfcPPBasicType( "BINARY",	"std::wstring", "Binary" ) ) ) );

	m_schema_namespace = "";
	m_header_comment = "/* Code generated by IfcQuery EXPRESS generator, www.ifcquery.com */\n";
}

ExpressToSourceConverter::~ExpressToSourceConverter(){}

void ExpressToSourceConverter::setPathOut( QString path_out )
{
	if( !path_out.endsWith( "/" ) )
	{
		path_out = path_out + "/";
	}
	while( ( path_out.length() ) > 0 && ( path_out.at(0) == QChar('/') || path_out.at(0) == QChar('\\') ) )
	{
		path_out = path_out.right( path_out.length()-1 );
	}
	m_path_out = path_out;
}

void ExpressToSourceConverter::setSubfolderClasses( QString subfolder_h )
{
	if( !subfolder_h.endsWith( "/" ) )
	{
		subfolder_h = subfolder_h + "/";
	}
	while( ( subfolder_h.length() ) > 0 && ( subfolder_h.at(0) == QChar('/') || subfolder_h.at(0) == QChar('\\') ) )
	{
		subfolder_h = subfolder_h.right( subfolder_h.length()-1 );
	}
	m_subfolder_classes = subfolder_h;
}

void ExpressToSourceConverter::setFilenamePrefix( QString pre )
{
	m_filename_prefix = pre;
}

void ExpressToSourceConverter::parseSchemaFiles( QStringList content_in )
{
	m_map_entities.clear();
	m_map_types.clear();
	m_num_skipped_files = 0;

	// read schema files
	foreach( QString content, content_in )
	{
		parseSchema( content );
	}

	processTypesAndEntities();

	// write out files
	writeEntityClassFiles();

	writeTypeFactory();
	writeEntityFactory();

	if( m_num_skipped_files > 0 )
	{
		emit( signalTxtOut( "skipped files (no changes):\t" + QString::number(m_num_skipped_files) ) );
	}

	emit( signalTxtOut( "writing parser" ) );
	emit( signalProgressValue( 1000 ) );
	emit( signalTxtOut( "done" ) );
}

void ExpressToSourceConverter::parseSchema( QString content )
{
	// remove comments
	QRegExp rx_comment1( "\\(\\*(.|[\r\n])*\\*\\)" );
	rx_comment1.setMinimal( true );
	content.remove( rx_comment1 );

	// remove single line comments
	content.remove( QRegExp( "--[^\n]*" ) );

	QString schema_version;
	QRegExp rx_schema( "SCHEMA\\s*([a-zA-Z0-9_]+);" );
	if( rx_schema.indexIn( content, 0 ) >= 0 )
	{
		QString detected_schema = rx_schema.cap( 1 );

		QRegExp rx_major_minor( "IFC([0-9])+X([0-9])+" );
		if( rx_major_minor.indexIn( detected_schema, 0 ) >= 0 )
		{
			QString ifc_major = rx_major_minor.cap( 1 );
			QString ifc_minor = rx_major_minor.cap( 2 );
		
			detected_schema = "IFC" + ifc_major + "X" + ifc_minor;
		}
		schema_version = detected_schema;
		content.remove( rx_schema );
		emit( signalTxtOut( "detected schema version " + detected_schema ) );
	}
	else
	{
		emit( signalTxtOutWarning( "parseSchema: no schema version detected " ) );
	}
	
	emit( signalTxtOut( "extracting types and entities from schema" ) );
	int complete_size = content.size();
	findConstants( content, complete_size, schema_version );
	findTypes( content, complete_size, schema_version );
	findEntities( content, complete_size, schema_version );
	findFunctions( content, complete_size, schema_version );
	
	QRegExp rx_schema_end( "END_SCHEMA;" );
	if( rx_schema_end.indexIn( content, 0 ) < 0 )
	{
		emit( signalTxtOutWarning( "no END_SCHEMA; statement" ) );
	}
	content.remove( QRegExp( "END_SCHEMA;" ) );
	content.remove( QString( "\r" ) );
	content.remove( QString( "\n" ) );
	content.remove( QString( " " ) );
	content.remove( QString( "\t" ) );

	if( content.size() > 0 )
	{
		emit( signalTxtOutWarning( "remaining schema:\n" + content ) );
	}

	return;
}

void ExpressToSourceConverter::processTypesAndEntities()
{
	emit( signalTxtOut( "parsing" ) );
	size_t num_types = 0;
	size_t num_entities = 0;
	size_t num_types_and_entities = 0;
	num_types_and_entities += m_map_types.size();
	num_types_and_entities += m_map_entities.size();

	for( auto it_types = m_map_types.begin(); it_types != m_map_types.end(); ++it_types )
	{
		shared_ptr<Type>  t = it_types->second;
		try
		{
			t->parseType();
		}
		catch( std::exception& e )
		{
			emit( signalTxtOutWarning( e.what() ) );
		}
		
		++num_types;
		double progress = (double)(num_types+num_entities)/(num_types_and_entities);
		emit( signalProgressValue( 100+(int)(progress*100) ) );
	}

	for( auto it_entities = m_map_entities.begin(); it_entities != m_map_entities.end(); ++it_entities )
	{
		shared_ptr<Entity>  e = it_entities->second;
		try
		{
			e->parseEntity();
		}
		catch( std::exception& err )
		{
			emit( signalTxtOutWarning( err.what() ) );
		}

		++num_entities;
		double progress = (double)(num_types+num_entities)/(num_types_and_entities);
		emit( signalProgressValue( 200+(int)(progress*800) ) );
	}


	for( auto it_types = m_map_types.begin(); it_types != m_map_types.end(); ++it_types )
	{
		shared_ptr<Type>  t = it_types->second;
		t->linkDependencies();
	}

	for( auto it_entities = m_map_entities.begin(); it_entities != m_map_entities.end(); ++it_entities )
	{
		shared_ptr<Entity>  e = it_entities->second;
		e->linkDependencies();
	}

	emit( signalTxtOut( "processed types: " + QString::number( num_types ) ) );
	emit( signalTxtOut( "processed entities: " + QString::number( num_entities ) ) );
}

void ExpressToSourceConverter::slotEmitTxtOut( QString txt )
{
	emit( signalTxtOut( txt ) );
}


void ExpressToSourceConverter::slotEmitTxtOutWarning( QString txt )
{
	emit( signalTxtOutWarning( txt ) );
}

bool ExpressToSourceConverter::findTypes( QString& content, int complete_size, QString schema_version )
{
	int pos_type_begin=0;
	QRegExp rx_type_begin( "\\bTYPE\\s+([a-zA-Z0-9_]+)\\s*=" );

	while( (pos_type_begin = rx_type_begin.indexIn( content, pos_type_begin ) ) != -1 )
	{
		QString complete_match = rx_type_begin.cap(0);
		QString type_name = rx_type_begin.cap(1);
		QString schema;

		int pos_type_end;
		QRegExp rx_type_end( "END_TYPE;" );
		rx_type_end.setMinimal( true );
		if( (pos_type_end = rx_type_end.indexIn( content, pos_type_begin ) ) == -1 )
		{
			emit( signalTxtOutWarning( "findTypes: no END_TYPE found" ) );
			break;
		}
		int length_type = pos_type_end - pos_type_begin;
		if( length_type > 0 )
		{
			int length_type_end = rx_type_end.matchedLength();
			QStringRef type_str_ref(&content, pos_type_begin, length_type);
			QString type_str = type_str_ref.toString();
			schema = type_str;
			content.remove( pos_type_begin, length_type + length_type_end );
		}
		else
		{
			emit( signalTxtOutWarning( "parseSchema: length_type == 0" ) );
			break;
		}

		shared_ptr<Type>  type( new Type( this ) );
		type->m_className = type_name;
		type->setSchema( schema );
		
		type->setSchemaVersion( schema_version );

		QString key = type_name;
		if( m_map_types.find( key ) != m_map_types.end() )
		{
			emit( signalTxtOutWarning( "parseSchema: type " + type_name + " already in m_map_types" ) );
		}
		else
		{
			m_map_types.insert( std::pair<QString,shared_ptr<Type> >(key,type ) );
		}
		

		double progress = (double)(complete_size-content.size())/(double)complete_size;
		emit( signalProgressValue( (int)(progress*40.0) ) );
	}
	return true;
}

bool ExpressToSourceConverter::findEntities( QString& content, int complete_size, QString schema_version )
{
	// first pass, collect all type names
	int pos_entity_begin=0;
	QRegExp rx_entity_begin( "\\bENTITY\\s+([a-zA-Z0-9_]+)\\s*" );

	while( (pos_entity_begin = rx_entity_begin.indexIn( content, pos_entity_begin ) ) != -1 )
	{
		QString complete_match = rx_entity_begin.cap(0);
		QString entity_name = rx_entity_begin.cap(1);
			
		QString schema;
		int pos_entity_end;
		QRegExp rx_entity_end( "END_ENTITY;" );
		rx_entity_end.setMinimal( true );
		if( (pos_entity_end = rx_entity_end.indexIn( content, pos_entity_begin ) ) == -1 )
		{
			emit( signalTxtOutWarning( "findEntities: no END_ENTITY found" ) );
			break;
		}
		int length_entity = pos_entity_end - pos_entity_begin;
		if( length_entity > 0 )
		{
			int length_entity_end = rx_entity_end.matchedLength();
			QStringRef entity_str_ref(&content, pos_entity_begin, length_entity);
			QString entity_str = entity_str_ref.toString();
			schema = entity_str;
			content.remove( pos_entity_begin, length_entity + length_entity_end );
		}
		else
		{
			emit( signalTxtOutWarning( "findEntities: length_entity == 0" ) );
			break;
		}

		shared_ptr<Entity>  entity( new Entity( this ) );
		entity->m_entity_name = entity_name;
		entity->setSchema( schema );
		
		entity->setSchemaVersion( schema_version );

		if( m_map_entities.find( entity_name ) != m_map_entities.end() )
		{
			emit( signalTxtOutWarning( "findEntities: Entity " + entity_name + " already in map"  ) );
		}
		else
		{
			m_map_entities.insert( std::pair<QString,shared_ptr<Entity> >(entity_name,entity ) );
		}
	
		double progress = (double)(complete_size-content.size())/(double)complete_size;
		emit( signalProgressValue( 40+(int)(progress*60.0) ) );
	}
	return true;
}

void ExpressToSourceConverter::writeFile( QString path, QString& content )
{
	std::stringstream sstr;
	//const QChar* content_char = content.constData();
	CodeFormat::format_indentation( content.toLatin1(), sstr );
	QString formatted_content = sstr.str().c_str();
	while( path.at(0) == QChar('/') || path.at(0) == QChar('\\') )
	{
		path = path.right( path.length()-1 );
	}

	QString base_path = m_path_out;// +m_subfolder_all;
	int comp = path.left( base_path.length() ).compare( base_path );
	if( comp == 0 )
	{
		path.remove( 0, base_path.length() );
	}

	// check if file content has changed
	QString file_out_path = m_path_out + /*m_subfolder_all +*/ path;
	if( QFile::exists( file_out_path ))
	{
		QFile file_existing( file_out_path );
		file_existing.open( QFile::ReadOnly );

		QByteArray ba_existing = file_existing.readAll();
		ba_existing = ba_existing.replace( "\r\n", "\n");
		QString qstr_exsisting( ba_existing );
		
		if( qstr_exsisting.compare(formatted_content)== 0)
		{
			// content is equal
			++m_num_skipped_files;
			//emit( signalTxtOut( "skipped file (no changes):\t" + m_path_out + m_subfolder_all + path ) );
			file_existing.close();
			return;
		}
	}


	QFile file_out( file_out_path );
	QFileInfo file_out_info( file_out_path );

	QDir abs_dir = file_out_info.absoluteDir();
	QString abs_file_path = file_out_info.absoluteFilePath();
	QString abs_path = file_out_info.absolutePath();

	if( !abs_dir.exists( abs_path ) )
	{
		if( !abs_dir.mkpath( abs_path ) )
		{
			emit( signalTxtOutWarning( "couldn't create dir " + abs_file_path ) );
			return;
		}
	}

	if( !file_out.open(QIODevice::WriteOnly | QIODevice::Text) )
	{
		emit( signalTxtOutWarning( "couldn't write file " + path ) );
		return;
	}

	QTextStream file_out_stream( &file_out );
	file_out_stream << sstr.str().c_str();
	file_out.close();

	emit( signalTxtOut( "file written:\t" + path ) );
}

bool ExpressToSourceConverter::writeEntityClassFiles()
{
	emit( signalTxtOut( "generating classes" ) );

	int processed = 0;
	int num_process = 0;
	num_process += (int)(m_map_entities.size());
	num_process += (int)(m_map_types.size());

	QStringList extensions_h;
	extensions_h << "*.h" << "*.hxx" << "*.hpp";
	QStringList extensions_cpp;
	extensions_cpp << "*.cpp" << "*.cxx" << "*.cc" << "*.c" << "*.c++" << "*.txx" << "*.tpp";

	QString source_path( m_path_out + m_subfolder_classes );
	QString headers_path( source_path + "include/" );
	QString cpp_path( source_path + "lib/" );

	QDir directory_source( cpp_path );
	directory_source.setSorting(QDir::Name);
	directory_source.setNameFilters( extensions_cpp );
	directory_source.setFilter(QDir::Files | QDir::NoDotAndDotDot);
	QStringList items_currently_in_source_directory = directory_source.entryList();

	QDir directory_headers( headers_path );
	directory_headers.setSorting(QDir::Name);
	directory_headers.setNameFilters( extensions_h );
	directory_headers.setFilter(QDir::Files | QDir::NoDotAndDotDot);
	QStringList items_currently_in_header_directory = directory_headers.entryList();

	// write the header file
	for( auto it_types = m_map_types.begin(); it_types != m_map_types.end(); ++it_types )
	{
		shared_ptr<Type>  t = it_types->second;

		// h file
		QString content_h = t->getCodeHeader();
		writeFile( headers_path + t->m_className + ".h", content_h );

		// cpp file
		QString content_cpp( t->getCodeCpp() );
		writeFile( cpp_path + t->m_className + ".cpp", content_cpp );

		QString subolder_classes( m_subfolder_classes );
		if( subolder_classes.endsWith( "/" ) )
		{
			subolder_classes = subolder_classes.left( subolder_classes.size() - 1 );
		}

		QString class_name = t->m_className;
		QString reader_args = "std::wstring& arg";

		if( t->m_reader_needs_object_map )
		{
			QString namesp;
			reader_args = "std::wstring& arg, const map_t<int,shared_ptr<" + namesp + m_filename_prefix + "Entity> >& map";
		}

		++processed;
		emit( signalProgressValue( ((double)processed/(num_process)*1000) ) );

		for( int i=0; i<items_currently_in_source_directory.size(); ++i )
		{
			QString item_source = items_currently_in_source_directory.at(i);
			if( item_source.compare( t->m_className + ".cpp", Qt::CaseInsensitive ) == 0 )
			{
				items_currently_in_source_directory.erase(  items_currently_in_source_directory.begin() + i );
				break;
			}
		}
		for( int i=0; i<items_currently_in_header_directory.size(); ++i )
		{
			QString item_header = items_currently_in_header_directory.at(i);
			if( item_header.compare( t->m_className + ".h", Qt::CaseInsensitive ) == 0 )
			{
				items_currently_in_header_directory.erase(  items_currently_in_header_directory.begin() + i );
				break;
			}
		}

	}

	// entities
	for( auto it_entities = m_map_entities.begin(); it_entities != m_map_entities.end(); ++it_entities )
	{
		shared_ptr<Entity>  e = it_entities->second;

		// h file
		QString content_h = e->getCodeHeader();
		writeFile( headers_path + e->m_entity_name + ".h", content_h );

		// cpp file
		QString content_cpp( e->getCodeCpp() );
		writeFile( cpp_path + e->m_entity_name + ".cpp", content_cpp );

		// all include file
		QString subolder_classes( m_subfolder_classes );
		if( subolder_classes.endsWith( "/" ) )
		{
			subolder_classes = subolder_classes.left( subolder_classes.size() - 1 );
		}
		
		++processed;
		emit( signalProgressValue( ((double)processed/(num_process)*1000) ) );

		for( int i=0; i<items_currently_in_source_directory.size(); ++i )
		{
			QString item_source = items_currently_in_source_directory.at(i);
			if( item_source.compare( e->m_entity_name + ".cpp", Qt::CaseInsensitive ) == 0 )
			{
				items_currently_in_source_directory.erase(  items_currently_in_source_directory.begin() + i );
				break;
			}
		}
		for( int i=0; i<items_currently_in_header_directory.size(); ++i )
		{
			QString item_header = items_currently_in_header_directory.at(i);
			if( item_header.compare( e->m_entity_name + ".h", Qt::CaseInsensitive ) == 0 )
			{
				items_currently_in_header_directory.erase(  items_currently_in_header_directory.begin() + i );
				break;
			}
		}
	}

	// delete files in the source folder that are not part of the current schema
	foreach( QString remaining_source, items_currently_in_source_directory )
	{
		emit( signalTxtOut( "remaining_source :\t" + remaining_source + ", going to delete" ) );
		QFile source_file( source_path + remaining_source );
		if( source_file.exists() )
		{
			source_file.remove();
		}
	}
	foreach( QString remaining_header, items_currently_in_header_directory )
	{
		emit( signalTxtOut( "remaining_header :\t" + remaining_header + ", going to delete" ) );
		QFile header_file( source_path + "include/" + remaining_header );
		if( header_file.exists() )
		{
			header_file.remove();
		}
	}
	
	return true;
}

void ExpressToSourceConverter::writeTypeFactory()
{
	QString type_includes;
	QString namespace_cpp;
	if( m_schema_namespace.length() > 0 )
	{
		namespace_cpp = m_schema_namespace + "::";
	}
	const QString subfolder_ifc_classes = m_subfolder_classes;
	const QString filename_prefix = m_filename_prefix;
	QString add_ifcpp = m_add_ifcpp_in_path ? "ifcpp/" : "";

	QString type_map = "static std::map<std::string, std::function<shared_ptr<IfcPPObject>( const std::wstring&, const std::map<int, shared_ptr<IfcPPEntity> >& )> > type_factory_map = {\n";

	std::map<QString, shared_ptr<Type> >::iterator it_types;
	std::map<QString, shared_ptr<TypeEntityContainer> >::iterator it_releases;
	std::map<QString, shared_ptr<Type> >	map = m_map_types;
	for( it_types = map.begin(); it_types != map.end(); ++it_types )
	{
		shared_ptr<Type>  t = it_types->second;

		QString class_name_upper = t->m_className.toUpper();
		type_includes += "#include \"" + add_ifcpp + subfolder_ifc_classes + "include/" + t->m_className + ".h\"\n";

		type_map += "{ \"" + class_name_upper + "\", []( const std::wstring& arg, const std::map<int, shared_ptr<IfcPPEntity> >& map )->shared_ptr<IfcPPObject> { return " + namespace_cpp + t->m_className + "::createObjectFromSTEP( arg, map ); } },\n";

		if( t->m_select.size() > 0 )
		{
			// don't create new object for abstract select types
			//continue;
		}
	}

	QString factory_cpp( m_header_comment );
	type_map.remove( type_map.size() - 2, 2 );// = ",\n";
	type_map += "};\n";

	factory_cpp += "\n";
	factory_cpp += "#include <map>\n";
	factory_cpp += "#include \"" + add_ifcpp + "model/IfcPPBasicTypes.h\"\n";
	factory_cpp += type_includes;
	factory_cpp += "#include \""+ filename_prefix +"TypeFactory.h\"\n\n";
	factory_cpp += type_map + "\n";
	factory_cpp += "shared_ptr<IfcPPObject> " + filename_prefix + "TypeFactory::createTypeObject( const std::string& class_name_upper, const std::wstring& type_arg, const std::map<int, shared_ptr<IfcPPEntity> >& map_entities )\n";
	factory_cpp += "{\n";
	factory_cpp += "	auto it_find = type_factory_map.find( class_name_upper );\n";
	factory_cpp += "	if( it_find != type_factory_map.end() )\n";
	factory_cpp += "	{\n";
	factory_cpp += "		return it_find->second( type_arg, map_entities );\n";
	factory_cpp += "	}\n";
	factory_cpp += "	// class_name not registered\n";
	factory_cpp += "	return shared_ptr<IfcPPObject>();\n";
	factory_cpp += "}\n";

	if( !m_include_comments )
	{
		factory_cpp.remove( QRegExp( "//[^\n]*" ) );
		factory_cpp.replace( QRegExp( "\n\\s*\n" ), "\n" );
	}

	writeFile( subfolder_ifc_classes + filename_prefix +"TypeFactory.cpp", factory_cpp );
}


void ExpressToSourceConverter::writeEntityFactory()
{
	QString entity_includes;
	QString namespace_cpp;
	if( m_schema_namespace.length() > 0 )
	{
		namespace_cpp = m_schema_namespace + "::";
	}
	const QString subfolder_ifc_classes = m_subfolder_classes;
	const QString filename_prefix = m_filename_prefix;
	QString add_ifcpp = m_add_ifcpp_in_path ? "ifcpp/" : "";

	QString entity_map = "static std::map<std::string, std::function<IfcPPEntity*( void )> > entity_factory_map = {\n";

	std::map<QString, shared_ptr<Entity> >	map = m_map_entities;
	for( auto it_entities = map.begin(); it_entities != map.end(); ++it_entities )
	{
		shared_ptr<Entity>  ent = it_entities->second;
		QString class_name_upper = ent->m_entity_name.toUpper();
		entity_includes += "#include \"" + add_ifcpp + subfolder_ifc_classes + "include/" + ent->m_entity_name + ".h\"\n";
		entity_map += "{ \"" + class_name_upper + "\", []( void )->IfcPPEntity* { return new " + namespace_cpp + ent->m_entity_name + "(); } },\n";
	}

	QString factory_cpp( m_header_comment );
	entity_map.remove( entity_map.size() - 2, 2 );// = ",\n";
	entity_map += "};\n";

	factory_cpp += "\n";
	factory_cpp += "#include <map>\n";
	factory_cpp += "#include \"" + add_ifcpp + "model/IfcPPBasicTypes.h\"\n";
	factory_cpp += entity_includes;
	factory_cpp += "#include \"" + filename_prefix + "EntityFactory.h\"\n\n";
	factory_cpp += entity_map + "\n";
	factory_cpp += "IfcPPEntity* " + filename_prefix + "EntityFactory::createEntityObject( const std::string& class_name_upper )\n";
	factory_cpp += "{\n";
	factory_cpp += "	auto it_find = entity_factory_map.find( class_name_upper );\n";
	factory_cpp += "	if( it_find != entity_factory_map.end() )\n";
	factory_cpp += "	{\n";
	factory_cpp += "		return it_find->second();\n";
	factory_cpp += "	}\n";
	factory_cpp += "	// class_name not registered\n";
	factory_cpp += "	return nullptr;\n";
	factory_cpp += "}\n";

	if( !m_include_comments )
	{
		factory_cpp.remove( QRegExp( "//[^\n]*" ) );
		factory_cpp.replace( QRegExp( "\n\\s*\n" ), "\n" );
	}

	writeFile( subfolder_ifc_classes + filename_prefix + "EntityFactory.cpp", factory_cpp );
}

bool ExpressToSourceConverter::findConstants( QString& file_content, int complete_size, QString schema_version )
{
	int pos_begin=0;
	QRegExp rx_begin( "\\b(CONSTANT)\\s([a-zA-Z0-9_]*)[\\s]*" );
	while( (pos_begin = rx_begin.indexIn( file_content, pos_begin ) ) != -1 )
	{
		QString complete_match = rx_begin.cap(0);
		QString type_name = rx_begin.cap(2);

		int pos_end;
		QRegExp rx_end( "END_CONSTANT;" );
		rx_end.setMinimal( true );
		if( (pos_end = rx_end.indexIn( file_content, pos_begin ) ) == -1 )
		{
			break;
			assert( 0 );
		}
		int length = pos_end - pos_begin;
		if( length > 0 )
		{
			int length_end = rx_end.matchedLength();

			QStringRef type_str_ref(&file_content, pos_begin, length);
			QString type_str = type_str_ref.toString();

			file_content.remove( pos_begin, length + length_end );
		}
		else
		{
			assert( 0 );
		}
	}
	return true;
}

bool ExpressToSourceConverter::findFunctions( QString& file_content, int complete_size, QString schema_version )
{
	int pos_type_begin=0;
	QRegExp rx_type_begin( "\\b(FUNCTION|RULE)\\s([a-zA-Z0-9_]*)[\\s]*" );
	while( (pos_type_begin = rx_type_begin.indexIn( file_content, pos_type_begin ) ) != -1 )
	{
		QString complete_match = rx_type_begin.cap(0);
		QString type_name = rx_type_begin.cap(2);

		int pos_type_end;
		QRegExp rx_type_end( "END_(FUNCTION|RULE);" );
		rx_type_end.setMinimal( true );
		if( (pos_type_end = rx_type_end.indexIn( file_content, pos_type_begin ) ) == -1 )
		{
			break;
			assert( 0 );
		}
		int length_type = pos_type_end - pos_type_begin;
		if( length_type > 0 )
		{
			int length_type_end = rx_type_end.matchedLength();

			QStringRef type_str_ref(&file_content, pos_type_begin, length_type);
			QString type_str = type_str_ref.toString();

			file_content.remove( pos_type_begin, length_type + length_type_end );
		}
		else
		{
			assert( 0 );
		}
	}
	return true;
}

// not enabled yet:
void ExpressToSourceConverter::writeCMakeFile()
{
	emit( signalTxtOut( "generating cmake file" ) );

	QString content_cmake_file;
	content_cmake_file += "list(APPEND ifcplusplus_CXX_SRC\n";

	// write the header file
	std::map<QString, shared_ptr<TypeEntityContainer> >::iterator it_releases;
	content_cmake_file += m_filename_prefix + "EntityFactory.cpp\n";

	std::map<QString, shared_ptr<Type> >::iterator it_types;
	for( it_types = m_map_types.begin(); it_types != m_map_types.end(); ++it_types )
	{
		shared_ptr<Type>  t = it_types->second;
		content_cmake_file += t->m_className + ".cpp\n";
	}

	std::map<QString, shared_ptr<Entity> >::iterator it_entities;
	for( it_entities = m_map_entities.begin(); it_entities != m_map_entities.end(); ++it_entities )
	{
		shared_ptr<Entity>  e = it_entities->second;
		content_cmake_file += e->m_entity_name + ".cpp\n";
	}

	content_cmake_file += ")\n";
	content_cmake_file += "set(ifcplusplus_CXX_SRC \"${ifcplusplus_CXX_SRC}\" PARENT_SCOPE)\n";

	writeFile( "CMakeLists.txt", content_cmake_file );
}
